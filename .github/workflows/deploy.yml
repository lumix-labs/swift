name: Deploy Application

on:
  workflow_call:
    inputs:
      infrastructureParams:
        required: true
        type: string
        description: 'JSON string containing infrastructure parameters'
      modulesToDeploy:
        required: true
        type: string
        description: 'Comma-separated list of modules to deploy'
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      AWS_ACCOUNT_ID:
        required: true
      EC2_SSH_KEY:
        required: false  # Made optional
  workflow_dispatch:
    inputs:
      instance_ip:
        description: 'EC2 Instance IP'
        required: true
        type: string
      modules_to_deploy:
        description: 'Comma-separated list of modules to deploy (api,web)'
        required: true
        type: string

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
        
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Parse parameters
        id: parse-params
        run: |
          # Make parse-params.sh executable
          chmod +x .github/scripts/parse-params.sh
          
          if [ -n "${{ inputs.infrastructureParams }}" ]; then
            # From workflow_call - use our parameter parser
            export PARAMS='${{ inputs.infrastructureParams }}'
            INSTANCE_IP=$(.github/scripts/parse-params.sh "$PARAMS" "instance_ip")
            MODULES_TO_DEPLOY="${{ inputs.modulesToDeploy }}"
          else
            # From workflow_dispatch
            INSTANCE_IP="${{ inputs.instance_ip }}"
            MODULES_TO_DEPLOY="${{ inputs.modules_to_deploy }}"
          fi
          
          echo "Parsed instance_ip: $INSTANCE_IP"
          
          # Validate instance_ip is not empty
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" == "null" ]; then
            echo "Error: Instance IP is empty or null. Cannot proceed with deployment."
            echo "This usually happens when infrastructure outputs are not available."
            exit 1
          fi
          
          echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
          echo "modules_to_deploy=${MODULES_TO_DEPLOY}" >> $GITHUB_OUTPUT
      
      - name: Create docker-compose file
        run: |
          mkdir -p deploy
          
          # Create docker-compose.yml content
          cat > deploy/docker-compose.yml << EOL
          version: '3'

          services:
          EOL
          
          # Convert comma-separated modules to array
          IFS=',' read -ra MODULES <<< "${{ steps.parse-params.outputs.modules_to_deploy }}"
          
          # Add each module to docker-compose
          for MODULE in "${MODULES[@]}"; do
            if [[ "$MODULE" == "api" ]]; then
              cat >> deploy/docker-compose.yml << EOL
            api:
              image: ${{ steps.login-ecr.outputs.registry }}/lumixlabs/swift-api:${{ github.sha }}
              ports:
                - "4000:4000"
              restart: always
              volumes:
                - ./logs/api:/logs
              environment:
                - NODE_ENV=production
                - PORT=4000
              healthcheck:
                test: ["CMD", "wget", "--spider", "-q", "http://localhost:4000/healthcheck"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s
              networks:
                - swift-network
          EOL
            elif [[ "$MODULE" == "web" ]]; then
              cat >> deploy/docker-compose.yml << EOL
            web:
              image: ${{ steps.login-ecr.outputs.registry }}/lumixlabs/swift-web:${{ github.sha }}
              ports:
                - "3050:3050"
              restart: always
              volumes:
                - ./logs/web:/logs
              environment:
                - NODE_ENV=production
                - PORT=3050
              healthcheck:
                test: ["CMD", "wget", "--spider", "-q", "http://localhost:3050/"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s
              networks:
                - swift-network
          EOL
            fi
          done
          
          # Add networks section
          cat >> deploy/docker-compose.yml << EOL

          networks:
            swift-network:
              driver: bridge
          EOL
      
      # Use AWS SSM for secure deployment instead of SSH
      - name: Generate deployment package
        run: |
          mkdir -p deployment
          cp deploy/docker-compose.yml deployment/
          cp .github/scripts/deploy-to-ec2.sh deployment/
          chmod +x deployment/deploy-to-ec2.sh
          
          # Create a metadata file for SSM
          cat > deployment/metadata.json << EOL
          {
            "instance_ip": "${{ steps.parse-params.outputs.instance_ip }}",
            "ecr_registry": "${{ steps.login-ecr.outputs.registry }}",
            "github_sha": "${{ github.sha }}"
          }
          EOL
          
          # Create a deployment script
          cat > deployment/run-deployment.sh << EOL
          #!/bin/bash
          set -e
          
          # Get ECR password using instance IAM role
          AWS_ECR_PASSWORD=\$(aws ecr get-login-password --region ${{ secrets.AWS_REGION }})
          
          # Create directories
          mkdir -p /app/logs/{api,web}
          chmod -R 777 /app/logs
          
          # Copy files to app directory
          cp docker-compose.yml /app/
          
          # Run deployment script
          AWS_ECR_PASSWORD="\$AWS_ECR_PASSWORD" AWS_ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}" ./deploy-to-ec2.sh
          EOL
          
          chmod +x deployment/run-deployment.sh
          
          # Create deployment archive
          cd deployment
          zip -r ../deployment.zip ./*
          cd ..
      
      - name: Deploy using AWS Systems Manager
        run: |
          INSTANCE_ID=$(.github/scripts/parse-params.sh '${{ inputs.infrastructureParams }}' "instance_id")
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: Instance ID is not available. Attempting to get it from AWS..."
            # Try to get instance ID from IP address
            INSTANCE_IP="${{ steps.parse-params.outputs.instance_ip }}"
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=public-ip-address,Values=$INSTANCE_IP" --query "Reservations[0].Instances[0].InstanceId" --output text)
            
            if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
              echo "Error: Could not determine instance ID for IP $INSTANCE_IP"
              exit 1
            fi
          fi
          
          echo "Deploying to instance: $INSTANCE_ID"
          
          # Upload deployment package to S3
          BUCKET_NAME="swift-deployments-${{ secrets.AWS_REGION }}-${{ secrets.AWS_ACCOUNT_ID }}"
          
          # Create bucket if it doesn't exist (will fail gracefully if it exists)
          aws s3api create-bucket --bucket $BUCKET_NAME --region ${{ secrets.AWS_REGION }} --create-bucket-configuration LocationConstraint=${{ secrets.AWS_REGION }} || true
          
          # Upload deployment package
          aws s3 cp deployment.zip s3://$BUCKET_NAME/deployments/${{ github.sha }}.zip
          
          # Create and run SSM command
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunRemoteScript" \
            --parameters '{"sourceType":["S3"],"sourceInfo":["{\"path\":\"https://s3.'${{ secrets.AWS_REGION }}'.amazonaws.com/'$BUCKET_NAME'/deployments/'${{ github.sha }}'.zip\"}"],"commandLine":["./run-deployment.sh"]}' \
            --timeout-seconds 600 \
            --output text \
            --query "Command.CommandId")
          
          echo "Deployment command ID: $CMD_ID"
          
          # Wait for command to complete
          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$INSTANCE_ID"
          
          # Get command result
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text)
          
          if [ "$RESULT" != "Success" ]; then
            echo "Deployment failed with status: $RESULT"
            aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi
          
          echo "Deployment completed successfully"
      
      - name: Verify Deployment
        run: |
          echo "Waiting for services to start..."
          sleep 30
          
          # Use AWS SSM to verify services
          INSTANCE_ID=$(.github/scripts/parse-params.sh '${{ inputs.infrastructureParams }}' "instance_id")
          
          if [ -z "$INSTANCE_ID" ]; then
            INSTANCE_IP="${{ steps.parse-params.outputs.instance_ip }}"
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=public-ip-address,Values=$INSTANCE_IP" --query "Reservations[0].Instances[0].InstanceId" --output text)
          fi
          
          # Convert comma-separated modules to array
          IFS=',' read -ra MODULES <<< "${{ steps.parse-params.outputs.modules_to_deploy }}"
          
          for MODULE in "${MODULES[@]}"; do
            if [[ "$MODULE" == "api" ]]; then
              echo "Checking API service..."
              aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters '{"commands":["curl -s http://localhost:4000/healthcheck || echo \"API service is not responding\""]}' \
                --output text
            elif [[ "$MODULE" == "web" ]]; then
              echo "Checking Web service..."
              aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters '{"commands":["curl -s http://localhost:3050/ || echo \"Web service is not responding\""]}' \
                --output text
            fi
          done