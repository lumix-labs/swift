name: Deploy Application

on:
  workflow_call:
    inputs:
      infrastructureParams:
        required: true
        type: string
        description: 'JSON string containing infrastructure parameters'
      modulesToDeploy:
        required: true
        type: string
        description: 'Comma-separated list of modules to deploy'
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      AWS_ACCOUNT_ID:
        required: true
      EC2_SSH_KEY:
        required: false
  workflow_dispatch:
    inputs:
      instance_ip:
        description: 'EC2 Instance IP'
        required: true
        type: string
      modules_to_deploy:
        description: 'Comma-separated list of modules to deploy (api,web)'
        required: true
        type: string

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
        
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true
      
      - name: Parse parameters
        id: parse-params
        run: |
          # Make parse-params.sh executable
          chmod +x .github/scripts/parse-params.sh
          
          if [ -n "${{ inputs.infrastructureParams }}" ]; then
            # From workflow_call - use our parameter parser
            export PARAMS='${{ inputs.infrastructureParams }}'
            INSTANCE_IP=$(.github/scripts/parse-params.sh "$PARAMS" "instance_ip")
            INSTANCE_ID=$(.github/scripts/parse-params.sh "$PARAMS" "instance_id")
            MODULES_TO_DEPLOY="${{ inputs.modulesToDeploy }}"
          else
            # From workflow_dispatch
            INSTANCE_IP="${{ inputs.instance_ip }}"
            INSTANCE_ID=""
            MODULES_TO_DEPLOY="${{ inputs.modules_to_deploy }}"
          fi
          
          echo "Parsed instance_ip: $INSTANCE_IP"
          
          # Validate instance_ip is not empty
          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" == "null" ]; then
            echo "Error: Instance IP is empty or null. Cannot proceed with deployment."
            echo "This usually happens when infrastructure outputs are not available."
            exit 1
          fi
          
          # If instance ID is not available, get it from the IP
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "null" ]; then
            echo "Attempting to get instance ID from IP address..."
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=public-ip-address,Values=$INSTANCE_IP" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)
              
            if [ "$INSTANCE_ID" == "None" ] || [ -z "$INSTANCE_ID" ]; then
              echo "Warning: Could not find instance ID for IP $INSTANCE_IP"
              echo "Will proceed with SSM session manager for deployment"
            else
              echo "Found instance ID: $INSTANCE_ID"
            fi
          fi
          
          echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
          echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT
          echo "modules_to_deploy=${MODULES_TO_DEPLOY}" >> $GITHUB_OUTPUT
      
      - name: Create docker-compose file
        run: |
          mkdir -p deploy
          
          # Create docker-compose.yml content
          cat > deploy/docker-compose.yml << EOL
          version: '3'

          services:
          EOL
          
          # Convert comma-separated modules to array
          IFS=',' read -ra MODULES <<< "${{ steps.parse-params.outputs.modules_to_deploy }}"
          
          # Add each module to docker-compose
          for MODULE in "${MODULES[@]}"; do
            if [[ "$MODULE" == "api" ]]; then
              cat >> deploy/docker-compose.yml << EOL
            api:
              image: ${{ steps.login-ecr.outputs.registry }}/lumixlabs/swift-api:${{ github.sha }}
              ports:
                - "4000:4000"
              restart: always
              volumes:
                - /app/logs/api:/logs
              environment:
                - NODE_ENV=production
                - PORT=4000
              healthcheck:
                test: ["CMD", "wget", "--spider", "-q", "http://localhost:4000/healthcheck"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s
              networks:
                - swift-network
          EOL
            elif [[ "$MODULE" == "web" ]]; then
              cat >> deploy/docker-compose.yml << EOL
            web:
              image: ${{ steps.login-ecr.outputs.registry }}/lumixlabs/swift-web:${{ github.sha }}
              ports:
                - "3050:3050"
              restart: always
              volumes:
                - /app/logs/web:/logs
              environment:
                - NODE_ENV=production
                - PORT=3050
              healthcheck:
                test: ["CMD", "wget", "--spider", "-q", "http://localhost:3050/"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 10s
              networks:
                - swift-network
          EOL
            fi
          done
          
          # Add networks section
          cat >> deploy/docker-compose.yml << EOL

          networks:
            swift-network:
              driver: bridge
          EOL
      
      # Create a direct SSM deployment script that doesn't use S3
      - name: Create deployment script
        run: |
          # Create deployment execution script
          cat > deploy/run-deployment.sh << 'EOL'
          #!/bin/bash
          set -e

          echo "Starting deployment at $(date)"

          # Create app directory if it doesn't exist
          mkdir -p /app/logs/{api,web}
          chmod -R 777 /app/logs

          # Copy docker-compose.yml to app directory
          cp docker-compose.yml /app/

          # Navigate to app directory
          cd /app

          # Get ECR credentials using instance profile
          if [ -n "${AWS_ECR_REGISTRY}" ]; then
            echo "Logging in to ECR..."
            # Use AWS command to get credentials and login to Docker securely
            # This prevents the password from being exposed in logs
            aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_ECR_REGISTRY}
          fi

          # Pull Docker images
          echo "Pulling Docker images..."
          docker-compose pull

          # Stop and remove existing containers
          echo "Stopping existing containers..."
          docker-compose down || true

          # Start new containers
          echo "Starting new containers..."
          docker-compose up -d

          # Check container status
          echo "Container status:"
          docker-compose ps

          echo "Deployment completed at $(date)"
          EOL
          
          chmod +x deploy/run-deployment.sh
      
      - name: Deploy using direct SSM command
        run: |
          INSTANCE_ID="${{ steps.parse-params.outputs.instance_id }}"
          INSTANCE_IP="${{ steps.parse-params.outputs.instance_ip }}"
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "null" ]; then
            echo "Warning: Instance ID not available. Trying to find instance using IP $INSTANCE_IP..."
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=public-ip-address,Values=$INSTANCE_IP" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)
              
            if [ "$INSTANCE_ID" == "None" ] || [ -z "$INSTANCE_ID" ]; then
              echo "Error: Could not determine instance ID for IP $INSTANCE_IP"
              exit 1
            fi
          fi
          
          echo "Deploying to instance: $INSTANCE_ID"
          
          # Check if we can connect to the instance via SSM
          CONNECTION_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
            --query "InstanceInformationList[0].PingStatus" \
            --output text)
            
          if [ "$CONNECTION_STATUS" != "Online" ]; then
            echo "Warning: Instance $INSTANCE_ID is not currently connected to SSM (status: $CONNECTION_STATUS)"
            echo "Waiting for SSM connection to become available..."
            
            # Wait for up to 2 minutes
            for i in {1..12}; do
              sleep 10
              CONNECTION_STATUS=$(aws ssm describe-instance-information \
                --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                --query "InstanceInformationList[0].PingStatus" \
                --output text)
                
              if [ "$CONNECTION_STATUS" == "Online" ]; then
                echo "Instance is now connected to SSM!"
                break
              fi
              
              if [ $i -eq 12 ]; then
                echo "Error: Instance failed to connect to SSM after 2 minutes"
                echo "Please ensure the instance has an IAM role with SSM permissions and the SSM agent is running"
                exit 1
              fi
            done
          fi
          
          # Create base64 encoded docker-compose file to avoid issues with quotes and whitespace
          DOCKER_COMPOSE_BASE64=$(base64 -w 0 deploy/docker-compose.yml)
          DEPLOYMENT_SCRIPT_BASE64=$(base64 -w 0 deploy/run-deployment.sh)
          
          # Send command to instance using SSM document - Fixed command syntax
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"echo 'Starting Swift deployment...'\",
              \"mkdir -p /tmp/swift-deploy\",
              \"cd /tmp/swift-deploy\",
              \"echo ${DOCKER_COMPOSE_BASE64} | base64 --decode > docker-compose.yml\",
              \"echo ${DEPLOYMENT_SCRIPT_BASE64} | base64 --decode > run-deployment.sh\",
              \"chmod +x run-deployment.sh\",
              \"AWS_ECR_REGISTRY='${{ steps.login-ecr.outputs.registry }}' AWS_REGION='${{ secrets.AWS_REGION }}' ./run-deployment.sh\"
            ]" \
            --timeout-seconds 600 \
            --output text \
            --query "Command.CommandId")
          
          echo "SSM command ID: $CMD_ID"
          
          # Wait for command to complete (add a timeout to avoid waiting indefinitely)
          timeout 10m aws ssm wait command-executed \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" || echo "Command timed out, continuing..."
          
          # Get command result
          RESULT=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text || echo "Failed to get command status")
          
          echo "Command status: $RESULT"
          
          if [ "$RESULT" != "Success" ]; then
            echo "Deployment failed with status: $RESULT"
            aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text || echo "Could not retrieve error content"
            exit 1
          fi
          
          echo "Deployment output:"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text || echo "Could not retrieve output content"
          
          echo "Deployment completed successfully"
      
      - name: Verify Deployment
        run: |
          INSTANCE_ID="${{ steps.parse-params.outputs.instance_id }}"
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "null" ]; then
            INSTANCE_IP="${{ steps.parse-params.outputs.instance_ip }}"
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=public-ip-address,Values=$INSTANCE_IP" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)
          fi
          
          echo "Waiting for services to start..."
          sleep 30
          
          # Verify services using SSM
          IFS=',' read -ra MODULES <<< "${{ steps.parse-params.outputs.modules_to_deploy }}"
          
          for MODULE in "${MODULES[@]}"; do
            if [[ "$MODULE" == "api" ]]; then
              echo "Checking API service..."
              
              VERIFY_CMD_ID=$(aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters commands="[\"cd /app && docker-compose ps api && curl -s http://localhost:4000/healthcheck || echo 'API service is not responding'\"]" \
                --output text \
                --query "Command.CommandId")
                
              sleep 5
              
              # Get verification result
              aws ssm get-command-invocation \
                --command-id "$VERIFY_CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text || echo "Could not verify API service"
              
            elif [[ "$MODULE" == "web" ]]; then
              echo "Checking Web service..."
              
              VERIFY_CMD_ID=$(aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters commands="[\"cd /app && docker-compose ps web && curl -s http://localhost:3050/ | head -20 || echo 'Web service is not responding'\"]" \
                --output text \
                --query "Command.CommandId")
                
              sleep 5
              
              # Get verification result
              aws ssm get-command-invocation \
                --command-id "$VERIFY_CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text || echo "Could not verify Web service"
            fi
          done